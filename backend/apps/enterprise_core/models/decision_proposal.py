from django.db import models
from apps.core_erp.base_models import TenantAwareModel
from django.conf import settings
import uuid

class DecisionProposal(TenantAwareModel):
    """
    Auditable persistent record of a decision recommendation generated by the engine.
    Integrated with GovernanceKernel for final validation.
    """
    class Status(models.TextChoices):
        PENDING = 'PENDING', 'Pending Approval'
        APPROVED = 'APPROVED', 'Approved'
        REJECTED = 'REJECTED', 'Rejected'
        EXECUTED = 'EXECUTED', 'Executed'
        FAILED = 'FAILED', 'Failed'

    origin_metric = models.CharField(max_length=100)
    metric_value = models.DecimalField(max_digits=20, decimal_places=4)

    evaluated_risk = models.FloatField(help_text="Calculated risk score 0.0 to 1.0")
    risk_category = models.CharField(max_length=50, default='OPERATIONAL')

    suggested_action = models.JSONField(help_text="Intent data: {'intention': '...', 'parameters': {...}}")

    governance_status = models.CharField(max_length=20, choices=Status.choices, default=Status.PENDING)
    approved_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="approved_proposals"
    )

    executed = models.BooleanField(default=False)
    execution_result = models.JSONField(null=True, blank=True)

    correlation_id = models.UUIDField(default=uuid.uuid4, db_index=True)

    # Audit SHA-256 Chaining
    integrity_hash = models.CharField(max_length=64, null=True, blank=True, db_index=True)
    previous_hash = models.CharField(max_length=64, null=True, blank=True)

    __schema_version__ = "v2.1"

    class Meta:
        app_label = 'enterprise_core'
        verbose_name = "Decision Proposal"
        verbose_name_plural = "Decision Proposals"
        ordering = ['-created_at']

    def save(self, *args, **kwargs):
        import hashlib
        import json
        from django.core.serializers.json import DjangoJSONEncoder
        from django.db import transaction

        if not self.integrity_hash:
            with transaction.atomic():
                # 1. Get previous hash with row-level lock to prevent race conditions
                last_proposal = DecisionProposal.plain_objects.select_for_update().order_by('-created_at').first()
                self.previous_hash = last_proposal.integrity_hash if last_proposal else "EOS_GENESIS_BLOCK"

                # 2. Calculate current hash
                payload = {
                    "id": str(self.id),
                    "metric": self.origin_metric,
                    "value": str(self.metric_value),
                    "action": self.suggested_action,
                    "previous_hash": self.previous_hash
                }
                payload_str = json.dumps(payload, sort_keys=True, cls=DjangoJSONEncoder)
                self.integrity_hash = hashlib.sha256(payload_str.encode()).hexdigest()
                super().save(*args, **kwargs)
        else:
            super().save(*args, **kwargs)

    def __str__(self):
        return f"Proposal {self.id} - {self.governance_status}"
