from typing import List, Dict, Any
from .tool import Tool
from .state import State
from .logger import Logger
import json
import inspect

class Executor:
    """
    Executes the plan generated by the Planner.
    """
    def __init__(self, tools: List[Tool], logger: Logger):
        self.tools = {tool.name: tool for tool in tools}
        self.logger = logger

    async def execute_plan(self, state: State) -> str:
        """
        Executes the entire plan step by step asynchronously.
        """
        plan_str = state.get("plan", "[]")
        try:
            plan = json.loads(plan_str)
        except json.JSONDecodeError:
            error_msg = "Executor: Invalid plan format. Expected a JSON array of steps."
            self.logger.log("Executor", error_msg, "ERROR")
            return error_msg

        execution_history = []

        for step in plan:
            step_num = step.get("step")
            tool_name = step.get("tool")
            params = step.get("params", {})

            self.logger.log("Executor", f"Executing Step {step_num}: Use tool '{tool_name}' with params {params}")

            if tool_name not in self.tools:
                observation = f"Tool '{tool_name}' not found."
                self.logger.log("Executor", observation, "ERROR")
            else:
                try:
                    resolved_params = self._resolve_params(params, execution_history)
                    tool = self.tools[tool_name]

                    # Execute tool asynchronously if it's a coroutine, otherwise sync
                    if inspect.iscoroutinefunction(tool.function):
                        observation = await tool.function(**resolved_params)
                    else:
                        observation = tool.function(**resolved_params)

                    self.logger.log("Executor", f"Observation from Step {step_num}: {observation}")
                except Exception as e:
                    observation = f"Error executing tool '{tool_name}': {e}"
                    self.logger.log("Executor", observation, "ERROR")

            execution_history.append({
                "step": step_num,
                "tool": tool_name,
                "params": params,
                "observation": str(observation)
            })

            state.set("execution_history", execution_history)

        if execution_history:
            return execution_history[-1].get("observation", "Execution completed.")
        else:
            return "No steps were executed."

    def _resolve_params(self, params: Dict[str, Any], history: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Resolves parameter values that reference outputs from previous steps.
        """
        resolved = {}
        for key, value in params.items():
            if isinstance(value, str) and "output of step" in value:
                try:
                    step_num_str = value.split(" ")[-1]
                    step_num = int(step_num_str)

                    referenced_observation = next(
                        (item["observation"] for item in history if item["step"] == step_num),
                        None
                    )

                    if referenced_observation is not None:
                        resolved[key] = referenced_observation
                    else:
                        raise ValueError(f"Could not find output for step {step_num}")

                except (ValueError, IndexError) as e:
                    self.logger.log("Executor", f"Could not resolve param '{value}': {e}", "WARNING")
                    resolved[key] = value
            else:
                resolved[key] = value
        return resolved
